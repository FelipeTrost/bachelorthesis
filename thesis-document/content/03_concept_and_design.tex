\chapter{Concept and Design}
\label{cha:conceptanddesign}

This chapter outlines the key components of the implementation of environments in the MS.
The core components are users, environments, roles, and assets.
In essence the concept can be summarized as follows: users can be part of to multiple environments.
Environments hold Assets.
Users that are part of an environment can work on the assets that are stored in it.
What a user can do with an asset is determined by the roles that the user has in the
environment that the asset is stored in.
All other components that will be introduced will help to manage and enforce these relationships.

\section{Modifications to Assets and Resources}

This thesis will modify the assets \ref{cha:relatedwork:proceed-assets} and the resources
\ref{cha:relatedwork:proceedroles:ms-resources-actions} supported by the MS.
Assets \ref{cha:conceptanddesign:environments:storing-assets} and 
Resources \ref{cha:conceptanddesign:roles} will be modified to be contained inside environments.
As will be explained in \ref{cha:conceptanddesign:users}, Users won't belong to an
environment, for this reason, users will be removed from the
MS's assets and resources.
Furthermore, folders \ref{cha:conceptanddesign:folders} and  memberships
\ref{cha:conceptanddesign:environments:memberships} will be added to the MS' assets and
resources.

\section{Users}
\label{cha:conceptanddesign:users}
%NOTE: maybe change the sctructure of this paragraph a bit

Previously users in the MS represented a member of a single organization.
In order for users to be part of multiple organizations, they can't be tied to a single
organization.
As a part of the implementation of environments, users are now independent of
organizations,
they now represent individual people utilizing PROCEED.
A single person can have one or more users, but each user is intended for individual use.

To facilitate the exploration of the MS, without creating a user, we introduce the option
to use the MS as a guest.
Thus, we differentiate between authenticated users and guest users.
Guest users have a limited feature. 
Guest users can transition to being an authenticated users whilst retaining their
assets, to do this they will need to sign in with personal data.
% Creating a Guest user doesn't require any data from the person creating it.

All users have a personal environment \ref{cha:conceptanddesign:environments:personal}
in which they can create and manage assets freely.
Authenticated users can also be part of and create organization environments
\ref{cha:conceptanddesign:environments:organization},
where they can collaborate with other users.

\subsection{Authenticated Users and Accounts}

% NOTE: is Oauth2 account the correct term here?
In order for the same user to be able to sign in with different Oauth2 providers, e.g. with Google,
Facebook or Discord, we store a separate record, called account, for each of the user's sign-in methods.
% NOTE: should one to many be explained?
This means, that the relationship between users and accounts is one-to-many,
a user can have multiple accounts, but an account can only be linked to one user.
This way, when a user is signing in with credentials from an Oauth2 provider, 
the MS can look up the corresponding account to the credentials, and then find the user
that the account is linked to.

% TODOFIG: show relationship between users and accounts;
% caption: Relationship between users and accounts.

\subsection{Merging a guest user with an authenticated user}
\label{cha:conceptanddesign:users:mergeguestuser}

As previously stated, a guest user can transition to being an authenticated user by
signing in with his personal data.
It could be the case that his personal data already corresponds to an existing user.
In this case, the user will be asked if he wants to merge his assets with the existing
authenticated user.
If he chooses to merge, all the assets in the guest user's personal environment will be
transferred to the authenticated user's personal environment.

\subsection{Guest User storage}

For storing guest user data, one could take one of two approaches:
storing the data in the user's browser or storing it in the MS's database, alongside the
data of authenticated users.
Storing the data locally has two great benefits: 
The MS doesn't have to store data of users who might never return and
the MS would become less susceptible to an attack where the attacker tries to use up as
much space as possible in the MS's storage solution.
However, this approach has one key downside, the MS would have to implement two storage
solutions and the frontend would need to switch accordingly between them.
The added complexity would make it harder for developers to get an overview of the MS's
codebase and it also makes it harder to use coding assistance features of IDEs like Goto
definition \footnote{\url{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_definition}}.
For this reason, storing guest user's data locally isn't worth the benefits.
We decided to store a guest user's data in the MS's just like for an authenticated user,
with the difference that a flag is set to indicate that he is a guest.
This way, all the endpoints that authenticated users can call to interact with the MS
can also be called by guest users.
An important caveat is that, to enforce some of the feature restrictions, relevant
endpoints have to check whether the user is a guest.

\subsection{Development Users}

When developing the MS, it is not common for the developer to have all the necessary keys
configured in the environment variables, for the MS to be able to authenticate users with
Oauth2 \ref{cha:relatedwork:oauth} or send sign-in emails.
For this reason the MS implements two development users: johndoe and admin.
When the MS is in development mode, i.e. the environment variable \lstinline{NODE_ENV} is
set to \lstinline{development},
the sign-in page shows a new input field where you can enter the developments user's username.
Both users are stored as authenticated users in the MS's database and can be used to test
the MS during development.


%TODO: say what guests can do?

% NOTE: I think this goes in implementation
% \subsection{Accounts}
%
% Accounts represent a use's sign in method. 

\section{Folders}
\label{cha:conceptanddesign:folders}

Folders are intended to allow organizations to mirror their hierarchical structure and
facilitate the organization of assets in general.
Starting from a root folder, users should be able to store assets within folders and nest
folders inside other folders, creating a flexible and intuitive structure. 
At the moment writing, folders only support processes, but they could be extended to
support other types of assets like the ones described in \ref{cha:relatedwork:proceed-assets}.

\subsection{Folder Structure model}

% TODO: say that because of the way the ms is built, the processes needs to be in a
% sepparate table

The folder structure is essentially just a rooted tree.
The MS doesn't use a database management system, thus it doesn't use a relational
language like SQL, still, the data is stored in a way that mimics a relational model.
For this reason the rooted folder tree needs to be mapped to a relational model.
% Methods mentioned in book
%
% Materialized path
% Nested sets -> store leftmost and rightmost of set
% Interval halving
% Matrix encoding
% Nested intervals
There are mainly three ways to model trees in relational models as outlined by Joe Celko in
\cite{celkoSQLTrees}: Adjacency List, Nested Set, and  Path Enumeration, more commonly known as Materialized Path.
Each of these models stores a node as a single entry, but they differ in how they encode
their position in the tree.

% Categories
% 1. finding direct descendandts / children
% 2. finding nth descendandts
% 3. finding ancestors / parent
% 4. finding nth ancestors
% 5. Adding
% 6. removing
% 7. Reorganization
%
\begin{itemize}
  \item \textbf{Adjacency List model}: Each node has an identifier and a reference to its parent.
    \begin{itemize}
      \item Advantages
        \begin{itemize}
        \item Finding a node's children is trivial.
        \item Finding a nodes' parent is trivial.
        \item Adding a node to the tree is trivial and doesn't require. 
        \item Moving nodes and their subtrees is trivial, since it only requires updating
          the parent reference. However, a check has to be made to ensure that the node's
            new parent isn't one of its descendants, thus creating a cycle.
        \end{itemize}
      \item Disadvantages
        \begin{itemize}
        \item Finding a node's descendants requires a recursive query, however,
          this is bounded by the depth of the tree and the amount of nodes.
        \item Finding a node's ancestors, i.e. all the nodes in the path from the root to
          the node, requires a recursive query, however, this is bounded by the height of
            the tree and should be efficient.
        \item Removing a node requires a recursive query to also delete its descendants,
          however, this is bounded by the depth of
            the tree and the amount of nodes.
      \end{itemize}
    \end{itemize}
  %-----------------------------------------------------------------------------------------------------------
  %-----------------------------------------------------------------------------------------------------------
  \item \textbf{Nested Set model}: Each node has a left and right value, describing an
    interval starting from the left value and ending at the right value.
    Children nodes' intervals are contained within the parent's interval. Furthermore, the
    intervals of siblings are disjoint.
    \begin{itemize}
      \item Advantages
        \begin{itemize}
        \item Finding the descendants of a node is trivial, the query has to select all
          nodes, whose interval is contained within the node's interval.
        \item Finding a node's ancestors is trivial, the query has to select the all the
          nodes with a left boundary smaller than the node's left boundary. 
        \item Finding a node's parent is trivial, the query has to select the node with
          the smallest left boundary that is bigger than the node's left boundary.
        \item Deleting a node and its subtree is trivial, the query is analogous to finding
          the descendants of a node.
        \end{itemize}
      \item Disadvantages
        \begin{itemize}
            % No se si me creo esta explicacion
        \item Finding a node's children requires a complex query, since it has to select
          only the node's children without also including the descendants of the
            children. This query can be inefficient because it has to apply additional filtering
            to retrieve only the direct children. This adds complexity and can slow down
            performance.
        \item Adding nodes is non-trivial, since it requires knowledge of its siblings to
          avoid overlapping intervals. Additionally depending on the implementation, it
            might require updating intervals of other nodes.
        \item Moving nodes and their subtrees is non-trivial, and inefficient, since it requires updating
          the intervals of the moved node, all of its descendants and depending on the
            implementation, the intervals of other nodes. 
        \end{itemize}
    \end{itemize}
  %-----------------------------------------------------------------------------------------------------------
  %-----------------------------------------------------------------------------------------------------------
  \item \textbf{Materialized Path model}: Each node stores the path from the root to itself.
    \begin{itemize}
      \item Advantages
        \begin{itemize}
        \item Finding a node’s ancestors or its parent is trivial, since the path is explicitly stored,
          the ancestors of a node can be retrieved simply by parsing the stored path.
        \item Finding a node’s descendants is easy and efficient, they can be found by
          querying for nodes whose paths start with the current node's path.
        \item Adding nodes is trivial, as the node's path can be constructed by appending
          the node's identifier to the parent's path.
        \item Removing a node and its subtree is trivial, as the node's descendants can be
          easily queried.
      \end{itemize}
      \item Disadvantages
        \begin{itemize}
          \item Finding a node's children is easy but, not as efficient as finding its
            descendants, as you need to perform one additional check to ensure that nodes
            are direct children.
        \item Moving nodes and their subtrees is inefficient, since it requires updating
          the path of every node in the subtree. 
        \end{itemize}
    \end{itemize}
\end{itemize}

% TODOFIG show simple examples for each model

% It is worth noting, that for each of these models, we will have to sepparately delete all
% processes that are stored in the folder
\definecolor{darkgreen}{rgb}{0.0, 0.45, 0.0}
\newcommand{\goodcomplexity}[1]{\vspace{.4em}\textcolor{darkgreen}{\checkmark}\vspace{.4em}}
\newcommand{\mediumcomplexity}[1]{\vspace{.4em}\textcolor{orange}{\textcircled{}}\vspace{.4em}}
\newcommand{\badcomplexity}[1]{\vspace{.4em}\textcolor{red}{X}\vspace{.4em}}

\newcommand{\goodefficency}[1]{\textcolor{darkgreen}{\checkmark}}
\newcommand{\mediumefficency}[1]{\textcolor{orange}{\textcircled{}}}
\newcommand{\badefficency}[1]{\textcolor{red}{X}}

\begin{figure}[H]
   \centering

\begin{tabular}{ | m{7.45em} | m{7em} | m{7em} | m{7em} | }
\hline
  & Adjacency List & Nested Set & Materialized Path \\
\hline
% ------------------------------------------------------------------------------
  find children & \goodcomplexity{Easy} \goodefficency{efficient} &
  \badcomplexity{Complex} \badefficency{inefficient} & \goodcomplexity{Easy}
  \mediumefficency{somewhat inefficient} \\
\hline
% ------------------------------------------------------------------------------
  find descendants & \goodcomplexity{Easy} \mediumefficency{somewhat inefficient} &
  \goodcomplexity{Easy} \goodefficency{efficient} &
  \goodcomplexity{Easy} \goodefficency{efficient} \\
\hline
% ------------------------------------------------------------------------------
  find parent & \goodcomplexity{Easy} \goodefficency{efficient} & \badcomplexity{Complex}
  \badefficency{inefficient} &  \goodcomplexity{Easy}  \goodefficency{efficient}\\
\hline
% ------------------------------------------------------------------------------
  find ancestors & \goodcomplexity{Easy} \goodefficency{efficient}  &
  \goodcomplexity{Easy} \goodefficency{efficient} & \goodcomplexity{Easy}
  \goodefficency{efficient} \\
\hline
% ------------------------------------------------------------------------------
  add nodes &  \goodcomplexity{Easy} \goodefficency{efficient} &
  \badcomplexity{Complex} \mediumefficency{possibly inefficient} &\goodcomplexity{Easy
  and} \goodefficency{efficient} \\
\hline
% ------------------------------------------------------------------------------
remove nodes & \goodcomplexity{Easy} \mediumefficency{somewhat inefficient}  &
  \goodcomplexity{Easy} \mediumefficency{possibly inefficient} &
  \goodcomplexity{Moderately complex} \goodcomplexity{somewhat inefficient} \\
\hline
% ------------------------------------------------------------------------------
move node &  \goodcomplexity{Easy} \goodcomplexity{efficient} & \badcomplexity{Complex}
  \badefficency{inefficient} & \mediumcomplexity{Moderately complex} \badcomplexity{inefficient}\\
\hline
% ------------------------------------------------------------------------------
\end{tabular}

\vspace{.5em}

\begin{tabular}{r@{: }l r@{: }l r@{: }l}
  \goodcomplexity{\textcircled{}}\vspace{-.8em} \_ & Easy query & \mediumcomplexity{}\vspace{-.8em} \_ &
  Moderately complex query &  \badcomplexity{}\vspace{-.8em} \_ & Complex query \\

  \_ \goodefficency{\textcircled{}} & Efficient & \_ \mediumefficency{} &
  Moderately efficient &  \_ \badefficency{} & Inefficient \\
\end{tabular}


\caption{Comparison between Adjacency List, Nested Set and Materialized Path models.}
\label{fig:comparison-db-tree-models}
\end{figure}

To choose the right model, we have to consider the requirements of the MS.
Users need to be able to view, add, delete and remove folders.
It becomes immediately clear, that the Nested Set model is not suitable for the MS, as
adding, removing and moving nodes is inefficient.
% The nested set model appears to be more useful for some analytical workloads.
That leaves us with the adjacency list and materialized path models.
The materialized path model has two small advantages, finding descendants is easier as it
only requires a query with a simple string comparison, and the same goes for removing a
folder and its subtree. 
However, the adjacency list model isn't far behind on those two points, and is
substantially more efficient when it comes to moving nodes.
Furthermore, the adjacency list model is better at finding children, which is more
valuable to the MS than finding descendants as the Process view will only show the
children.
For those reasons, the MS will use the adjacency list model to store the folder structure.

\subsection{Storing Assets inside folders}

Once the folder structure is implemented, it still is necessary to store assets inside
folders.
This thesis only implemented this feature for processes
\ref{cha:relatedwork:proceed-assets}, however, the same principle could be applied to
other assets.
A complete redesign of the process' data structures isn't feasible, as it would require
rewriting a large part of the MS.
For this reason a simple expansion to the data structure was chosen, where analogous to
the adjacency list model, each process stores a reference to the folder it is stored in.
This way, when moving a folder, it isn't required to update anything other than the
folder.
Moving an asset to another folder only requires updating the asset's reference.

% Folders are nodes in a rooted tree structure with a name and a description.
% Folders can contain other folders and assets.

% Each environment will have a folder structure to store its processes.
% The root folder is created when the environment is created.
% Each root folder and all of its children are contained by one and only one environment \ref{cha:conceptanddesign:environments}.


% Since the root folder belongs to only one environment, and all folders are stored below
% one root folder, all folders belong to only one environment.
% Processes will then store a reference to the folder they're stored in.

% TODO: ask kai if I should explain rooted trees - would be nice to cookup a formal def


\section{Environments}
\label{cha:conceptanddesign:environments}

Conceptually environments are where everything except users are stored.
Users aren't stored in environments as they can be a part of multiple environments.
Instead, the MS stores memberships that specify that a user is part of an environment.

There are two types of environments, personal and organization environments.
Personal environments intended for personal use and organization environments are intended
for organizations.

\subsection{Personal Environments}
\label{cha:conceptanddesign:environments:personal}

Personal environments are assigned to each user once they sign in. 
%NOTE: remove the part with owner
The user for which the environment is created, is the only member of this
environment, and is therefore called the owner.
No other users be a part of this environment.
%TODO: forward ref to folders
Personal environment only allow users to create and manage processes and folders,
other Features that the MS offers are disabled for personal environments and can only be
used in organization environments \ref{cha:conceptanddesign:environments:organization}.

\subsection{Organization Environments}
\label{cha:conceptanddesign:environments:organization}

Organization environments are intended to be used by organizations, thus they can have a
name, description and a logo.
Organization environments extend the feature set of personal environments, the enabled
resources \ref{cha:relatedwork:proceedroles:ms-resources-actions} for organization
environments can be determined when deploying a MS instance.

Organization environments can also have multiple Users that are part of it, these are
called members.

\subsection{Environment memberships}
\label{cha:conceptanddesign:environments:memberships}

\subsection{Storing assets inside environments}
\label{cha:conceptanddesign:environments:storing-assets}

All assets within the MS \ref{cha:relatedwork:proceed-assets}, including folders,
will be modified, so that each asset instance establishes a clear association with a single environment.
Every asset will store a reference to the environment it belongs to.
This reference is immutable, the only exception is when transferring the assets of a guest
user to an authenticated user \ref{cha:conceptanddesign:users:mergeguestuser}.

Processes and folders will be contained within folders, this implies, that they belong to
the environment that the root folder belongs to.
This means that for these assets, we are storing the environment they belong to twice.
Storing redundant information risky as it can lead to inconsistencies if updates aren't
done correctly.
For instance if a folder's environment reference is changed, but those of its children
not, then the folder structure would span across two environments.
This risk is mitigated by the fact, that the environment reference of assets is immutable.

% The key principle is that every asset belongs to one and only one environment, and this
% association can be easily identified.

% All of the MS's assets will only change in one way, they will somehow linked to an
% environment and only one.
% For processes, they're contained in a folder, such that they clearly belong to one
% environment. for other assets, they will store a reference to the environment they belong
% to.
% The important part is that each asset belongs to exactly one environment, and this
% environment can be identified.



\subsection{Environment selection}

% TODO: finish this
Users will be able to 

\section{Roles}
\label{cha:conceptanddesign:roles}

Before the implementation of this thesis, roles in the MS
\ref{cha:relatedwork:proceedroles} were global,
meaning that their permissions applied to all assets in the MS.
With the introduction of the folder structure in organization environments, this no longer makes sense.
Folders allow organizations to mirror their hierarchical structure, but this wouldn't be
entirely useful if roles were still global.
For this reason, roles can now be associated to a folder.
Roles that are associated with a folder cascade down the
folder structure, i.e. a role associated to a folder will also apply to all of its children.
Roles that aren't associated to a folder will continue to apply to all assets in the environment.
As roles are meant to mirror a users position in an organization, they're only available
for organization environments.

% TODOFIG: show how roles cascade

If a user's role allows him to view assets and is associated to a folder, then the user
also has the permission to view all parent folders of the folder the role is associated to.
But this is only restricted to the parent folders, not the contents of the parent folders.
This allows users to navigate the folder structure until they reach the assets they're
allowed to view and manage.

% TODOFIG: show how user can view path to his folder

\subsection{Abilities}
% TODO: roles send folder structure to user, is this bad? how could we mitigate it

\subsection{Default roles}

For each organization environment two roles will be created, which cannot be deleted and
cannot be associated to a folder:

\begin{itemize}
  \item \lstinline{@admin}: This role has all permissions for all assets in the
    organization environment and it is first assigned to the user that creates the organization environment.
    Only users with the \lstinline{@admin} role can add new users to this role.
  \item \lstinline{@everyone}: The permissions in this role apply to for all the users
    that are part of the organization environment. The permissions in this role start out
    empty, but can be modified.
\end{itemize}

