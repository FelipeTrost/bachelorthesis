\chapter{Implementation}
\label{cha:implementation}

In this chapter, we will
\footnote{\url{https://github.com/PROCEED-Labs/proceed}}

\section {MS Architecture}
\label{cha:ms-architecture}

Before diving into the implementation details of environments, it is important to
understand the architecture of the MS.
The MS is built using Next.js \footnote{\url{https://nextjs.org/}}, a React \footnote{\url{https://reactjs.org/}}
framework that allows for server-side rendering.
Altough Next.js' architecture is different from traditional server-side rendered
applications and single-page applications,
for the purposes of this thesis,
it can be thought of as being split into a single-page frontend and a backend.
The frontend executes JavaScript code in the user's browser, and is
responsible for rendering the UI, handling user input and making requests to the backend.
The backend runs on a server and is responsible for handling requests from the frontend,
e.g. saving or querying data.

\subsection{Data storage}
\label{cha:ms-architecture:data-storage}

% TODO: footnote or something for json

The MS doesn't use a database management system, instead it stores all data in JSON files.
Each file can be seen as a table in a traditional relational database.
Even though this approach allows for unstructured data, the MS uses 
Zod \footnote{\url{https://zod.dev/}} schemas to enforce a structure on
data that is stored.
Zod is a schema declaration and validation library, it allows the MS to define the shape
of JSON serializable data.
For purposes of simplicity, when we talk about a schema, instead of showing the code that
describes the Schema, we will show the typescript type that satisfies the schema.

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Example of a Zod schema and the corresponding TypeScript type.},
]
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  username: z.string(),
  image: z.string().optional(),
})

// TypeScript type that satisfies the UserSchema
type User = {
    id: string;
    username: string;
    image?: string | undefined;
}
\end{lstlisting}

% TODO: either finish this or remove it
% Additionally, the MS stores XML files for BPMN Assets.

\section{Users}


%
% \begin{lstlisting}[
%   language=JavaScript,
%   style=codestyle,
%   caption={Example setup of NextAuth.js.},
% ]
% const handler = NextAuth(nextAuthOptions);
% \end{lstlisting}

% TODO: this section
\subsection{Sign in flows}

User authentication is implemented by leveraging OpenID Connect\ref{cha:relatedwork:oauth:openid},
with the help of NextAuth.js\footnote{\url{https://next-auth.js.org/}}.
A JWT token \footnote{\url{https://www.rfc-editor.org/rfc/rfc7519.txt}}
is stored in the user's browser cookies\footnote{\url{https://www.rfc-editor.org/rfc/rfc7519.html}},
which is then parsed and verified by the MS' backend.
% TODO: is "id" the correct word here
If the JWT token is valid the user is considered authenticated.
If the user couldn't be authenticated, he is redirected to the sign-in page.

NextAuth.js has many sign-in methods built-in, which can be set up with little configuration.
For email-sign in, NextAuth.js sends an email with a link that the user has to click to
sign in.
We have to provide a way to store and query the tokens, that are encoded in the link and a
function that sends the email.
For OAuth2 providers, we only have to provide a client id and secret.

To store and look up users and accounts, NextAuth.js requires a database adapter,
which is a set of functions that interact with the database.
% TODO: add ref
The structure of the data that will be stored described in \ref{}.

NextAuth.js provides hooks that allow us to customize the sign-in flow, the most important
one for this thesis is the \lstinline{signIn} hook.
This hook is called when a user tries to sign in, this can be a new user or a returning
one.
As arguments, it receives the user's data, and the account that the user is trying to sign
in, if the user doesn't exist the user data may be empty.
If the hook returns true, the sign-in flow continues, if it returns a string or false,
then the sign-in flow is stopped, and the user is redirected to an error page.
Inside this hook, we can also check if the user was previously signed-in as a guest user
and is now signing in with personal information, so that we can merge the data of the two,
we will elaborate on this in \ref{cha:ms-architecture:merge-guest-user-data}.

% TODO: decicde if we need a setup example for nextauth.js

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Schema for authenticated users.},
]
import NextAuth from 'next-auth/next';
import GoogleProvider from 'next-auth/providers/google';

const authOptions = {
  providers: [
    EmailProvider({
      sendVerificationRequest({ url }) {
        // send email
      },
    }),
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
  ],
}

const handler = NextAuth(authOptions)
\end{lstlisting}


% (property) signIn?: ((params: {
%     user: User | AdapterUser;
%     account: Account | null;
%     profile?: Profile | undefined;
%     email?: {
%         verificationRequest?: boolean | undefined;
%     } | undefined;
%     credentials?: Record<string, CredentialInput> | undefined;
% }) => Awaitable<string | boolean>) | undefined
%
% Use this callback to control if a user is allowed to sign in.
% Returning true will continue the sign-in flow.
% Throwing an error or returning a string will stop the flow, and redirect the user.
%
% [Documentation](https://next-auth.js.org/configuration/callbacks#sign-in-callback)


\subsection{Authenticated Users}
\label{cha:ms-architecture:authenticated-users}

Authenticated Users are users that sign in to the MS either with their email or with a
OAuth 2.0 provider
For authenticated users we store an \lstinline{id}, a flag named \lstinline{isGuest}, set
to false, to indicate that the user isn't a guest and personal information.
This is the schema for authenticated users:

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Schema for authenticated users.},
]
{
    id: string;
    isGuest: false;
    emailVerifiedOn: Date | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    image?: string |  undefined;
    email?: string | undefined;
}
\end{lstlisting}

All the personal information is optional, because depending on how the user signs in, the
information might not be available.
For instance, because NextAuth.js' email sign in only requires the user to input an
email, authenticated users are created without a first name, last name or username.
A possible workaround would be to automatically generate these for 


It is important to understand the difference between Users and Accounts.
A user represent a person, while an accounts represents a method of signing in for a user.
A user can have multiple accounts, but an account can only be linked to one user.
To recognize an account we need to store the name of the provider and the account's
id on the provider's platform.
And to link the account to a User, we need to store the User's id on the MS.
This is the schema for accounts:

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Schema for accounts.},
]
{
    id: string;
    type: "oauth";
    userId: string;
    provider: string;
    providerAccountId: string;
}
\end{lstlisting}

\subsection{Guest Users}

Users that aren't signed in can choose to try the MS out as a guest, this doesn't require
the user to input any personal information.

For storing guest user data, one could take one of two approaches:
storing the data in the user's browser or storing it in the MS's database, alongside the
data of authenticated users.
Storing the data locally has two great benefits: 
The MS doesn't have to store data of users who might never return and
the MS would become less susceptible to an attack where the attacker tries to use up as
much space as possible in the MS's database.
However, this approach has one key downside, the MS would have to implement two storage
solutions and accordingly switch between them.
The added complexity of storing guest user's data locally isn't worth the benefits, so we
decided to store a guest user's data in the MS's database and create an entry for him in
the Database like for all users, with the difference that a flag is set, to indicate that
he is a guest.
This way, all the same endpoints that authenticated users can call to interact with the MS
can also be called by guest users.
An important caveat is that now all relevant endpoints have to check whether the user 


% TODO: finish


- user schema
- accounts represent ways for a user sign in
- user can have multiple accounts
- account linking
- sign in methods (+ dev sign in)


% \begin{lstlisting}[
%   style=codestyle,
%   caption={},
% ]
% {
%     isGuest: false;
%     emailVerifiedOn: Date | null;
%     firstName?: string | undefined;
%     lastName?: string | undefined;
%     username?: string | undefined;
%     image?: string | null | undefined;
%     favourites?: string[] | undefined;
%     id?: string | undefined;
%     email?: string | undefined;
% }
% \end{lstlisting}

\subsection{Merge guest user data with an authenticated user's data}
\label{cha:ms-architecture:merge-guest-user-data}

When a guest user decides to sign in with personal information, we have to merge the data


\section{Assets}

- environmentId stored on each thing to improve querying
- talk about data normalization
- talk about breaking normalization for perfomance gains -> reference a paper or smth

\section{Environments}

- environments are entry in db
- memberships
- environment format entry
- verification (when envs are created by not signed in users)
- creation
- deletion - managing the env
- section for folders
- decide how to divide 

Environments are stored as an entry in the MS table


\subsection{Creation}
\subsection{Memberships}

\section{Roles}


