\chapter{Implementation}
\label{cha:implementation}

\section {MS Architecture}

Before diving into the implementation details of environments, it is important to
understand the architecture of the MS.
The MS is built using Next.js \footnote{\url{https://nextjs.org/}}, a React \footnote{\url{https://reactjs.org/}}
framework that allows for server-side rendering.
Altough Next.js' architecture is different from traditional server-side rendered
applications and single-page applications,
for the purposes of this thesis,
it can be thought of as being split into a single-page frontend and a backend.
The frontend is the JavaScript code that is executed in the user's browser, which is
responsible for rendering the UI, handling user input and making requests to the backend.
The backend runs on a server, it is responsible for handling requests from the frontend,
e.g. saving or querying data.

\subsection{Data storage}

% TODO: footnote or something for json

The MS doesn't use a database management system, instead it stores all data in JSON files.
Each file can be seen as a table in a traditional relational database.
Even though this approach allows for unstructured data, the MS uses 
Zod \footnote{\url{https://zod.dev/}} schemas to enforce a structure on
data that is stored.
Zod is a schema declaration and validation library, it allows the MS to define the shape
of JSON serializable data.
For purposes of simplicity, when we talk about a schema, instead of showing the code that
describes the Schema, we will show the typescript type that satisfies the schema.

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Example of a Zod schema and the corresponding TypeScript type.},
]
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  username: z.string(),
  image: z.string().optional(),
})

// TypeScript type that satisfies the UserSchema
type User = {
    id: string;
    username: string;
    image?: string | undefined;
}
\end{lstlisting}

% TODO: either finish this or remove it
Additionally, the MS stores XML files for BPMN Assets.

\section{Users}

We authenticate users by storing a JWT
\footnote{\url{https://www.rfc-editor.org/rfc/rfc7519.html}} cookie in their browser.
This cookie is then parsed by the MS backend and if the cookie is valid and it stores the
% TODO: is "id" the correct word here
id of an existing user, the user is considered authenticated.
If the user couldn't be authenticated, he is redirected to the sign-in page.

\subsection{Authenticated Users}

Authenticated Users are users that sign in to the MS with personal information, be
% NOTE: is Oauth2 account the correct term here?
it an email or an Oauth2 account.
For authenticated users we store an \lstinline{id}, a flag named \lstinline{isGuest} set
to false, to indicate that the user isn't a guest and personal information about the user.
This is the schema for authenticated users:

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Schema for authenticated users.},
]
{
    id: string;
    isGuest: false;
    emailVerifiedOn: Date | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    image?: string |  undefined;
    email?: string | undefined;
}
\end{lstlisting}

It is important to understand the difference between Users and Accounts.
A user represent a person, while an accounts represents a method of signing in for a user.
A user can have multiple accounts, but an account can only be linked to one user.
To recognize an account we need to store the name of the provider and the account's
id on the provider's platform.
And to link the account to a User, we need to store the User's id on the MS.
This is the schema for accounts:

\begin{lstlisting}[
  language=JavaScript,
  style=codestyle,
  caption={Schema for accounts.},
]
{
    id: string;
    type: "oauth";
    userId: string;
    provider: string;
    providerAccountId: string;
}
\end{lstlisting}

\subsection{Guest Users}

Users that aren't signed in can choose to try the MS out as a guest, this doesn't require
the user to input any personal information.

For storing guest user data, one could take one of two approaches:
storing the data in the user's browser or storing it in the MS's database, alongside the
data of authenticated users.
Storing the data locally has two great benefits: 
The MS doesn't have to store data of users who might never return and
the MS would become less susceptible to an attack where the attacker tries to use up as
much space as possible in the MS's database.
However, this approach has one key downside, the MS would have to implement two storage
solutions and accordingly switch between them.
The added complexity of storing guest user's data locally isn't worth the benefits, so we
decided to store a guest user's data in the MS's database and create an entry for him in
the Database like for all users, with the difference that a flag is set, to indicate that
he is a guest.
This way, all the same endpoints that authenticated users can call to interact with the MS
can also be called by guest users.
An important caveat is that now all relevant endpoints have to check whether the user 


% TODO: finish


- user schema
- accounts represent ways for a user sign in
- user can have multiple accounts
- account linking
- sign in methods (+ dev sign in)


% \begin{lstlisting}[
%   style=codestyle,
%   caption={},
% ]
% {
%     isGuest: false;
%     emailVerifiedOn: Date | null;
%     firstName?: string | undefined;
%     lastName?: string | undefined;
%     username?: string | undefined;
%     image?: string | null | undefined;
%     favourites?: string[] | undefined;
%     id?: string | undefined;
%     email?: string | undefined;
% }
% \end{lstlisting}



\section{Assets}

- environmentId stored on each thing to improve querying
- talk about data normalization
- talk about breaking normalization for perfomance gains -> reference a paper or smth

\section{Environments}

- environments are entry in db
- memberships
- environment format entry
- verification (when envs are created by not signed in users)
- creation
- deletion - managing the env
- section for folders
- decide how to divide 

Environments are stored as an entry in the MS table


\subsection{Creation}
\subsection{Memberships}

\section{Roles}


